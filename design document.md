设计文档

语言

python

需求

1. 支持大文件传输，例如1G的电影
2. 包括客户端和服务端，遵从命令格式
3. 使用UDP作为传输层协议
4. 100%可靠性 （大量测试）
5. 流控制
6. 堵塞控制
7. 服务端并发访问控制
8. 提供有效查错信息

实现思路

- 服务端
  1. 在某IP某端口alway-on
- 客户端
  2. 对服务端发起上传、下载请求

功能：上传和下载，无损坏无间隔费冗余按序

先仅考虑上传功能：视频从客户端到服务端

基础设施：

- 基础设施：sender处理的主要事件

  - 接受到传输命令

    从文件系统读取文件数据，大文件->字节流->加上TCP有关头部（序号和确认号）并封装分组，估计往返时间，维护计时器；

  - 超时

    重传并重启定时器；

  - 接收到有效ACK字段值的报文段

    比较ACK携带的值y和SendBase

    ​	若y>SendBase，更新SendBase=y（则该ACK是在确认一个或多个先前未确认的报文段）；若当前仍有未被确认的报文段，重启定时器；

    ​	否则，递增ACK counter for y；若counter为3，重传报文段y   //快速重传

  - 超时间隔加倍

  - 回退N步还是选择重传

- 基础设施：receiver处理的主要事件

  - 维护一个接收buffer
  - 将数据段拆出放入buffer，若没有问题，将相关字节流接入文件系统；(buffer满/按序) 时将数据append到文件后

- 流控制

  - 下载时，server即sender；
  - 发送方跟踪两个变量并保证
  - 当接收到rwnd = 0，继续发送只有一个字节的分组，直到收到>0

- 堵塞控制

  原理：发送方感知网络行为0.0








传输的编码问题

f.read(mss)读出来的是类型为bytes的字节类型，是单纯的二进制流，输出显示的时候用16进制来表示。

int转bytes：byte([int])

bytes转int：ord(bytes([data[0]]))



通过二进制流文件头标识得到文件类型



rdt1.0 分片、传输、存入二进制文件，将二进制文件转换为格式文件。

rdt2.0 bit error checksum，ACK，重传

rdt2.1 分组序号ACK0/1



- 基础设施：差错检测和灰度
- 流控制：滑动窗口
- 拥塞控制
  1. 慢启动
  2. 拥塞避免
  3. 拥塞发生
  4. 快速恢复



命令传输和链接建立/断开：

- client接收到命令之后，向server发送连接请求（握手），包括client选择的（随机）初始序列号；若

- server是“总是运行”的；若server不处于运行状态，client检测到超时重发；如果请求超时5次，向控制台返回“Server does not Response”。

- server主线程启动，开启请求监听线程；

  - 若server监听到连接请求，返回客户端IP地址，接口和初始序列号给主线程
  - 如果该连接请求的IP地址未被处理过，创建新请求线程处理该请求，并将线程号加入到线程队列（先来先服务），每次取队列首部的线程进行服务；

- 请求处理线程

  - 线程唤醒，传入客户端IP地址，端口，命令和初始序列号

  - 线程分析命令
  - 若命令为上传文件，服务端发送：确认command的ACK和分配给该线程的RcvBuffer大小；
    - 客户端接收到该ACK分组后，更新rwnd，发送文件信息：文件名，文件字节数，文件格式和指定文件路径
    - 服务端接收到文件信息分组后，若文件路径不存在，返回deny请求；若存在指定文件路径初始化文件，开始接收
  - 若命令为接收文件，服务端发送确认command的ACK；
    - 客户端接收到该ACK之后，发送文件名，文件格式和目标文件路径；
    - 服务端接收到文件信息分组后，在本地搜索文件是否存在；若不存在返回deny请求，若存在，开始发送。

  - 接收到断开命令，回复ack进入半连接状态，接收到客户端第二次发送的断开连接，回复ack并完全断开；

图示：



差错检测和恢复设计：

发送方：

1. GBN：累计确认
2. 超时间隔加倍
3. 快速重传

接收方：

1. 确认最后一个按序到达的分组的序列号

2. 缓存失序到达的分组


发送方伪代码：

接收方伪代码：



流控制机制：

1. 建立连接握手时，接收方将RcvBuffer传输给发送方，发送方用于初始化变量rwnd

​	上传：

```python
	RcvBuffer, seq = struct.unpack(commandformat, reply)
    #...#
    rwnd = RcvBuffer    
```

​	下载：

```python

```

2. 发送方维护两个变量：LastByteSent和LastByteAcked；如果



堵塞控制机制：

发送方维护两个变量：

1. **拥塞窗口 ** cwnd 并保证 在一个发送方未被确认的数据量并会超过拥塞窗口和接收窗口中的最小值：
   $$
   LastByteSent - LastByteAcked <= min\{cwnd, rwnd\}*MSS
   $$

2. **慢启动阈值** ssthresh

3. **丢包事件**定义：超时或者收到接收方的3个冗余ACK；

慢启动，拥塞避免伪代码：

> 初始化：cwnd = 1*MSS，ssthresh = 16，dupACKcount = 0，state = 慢启动（0）；
>
> 慢启动：
>
> **WHILE** True
>
> ​	event : 接收newACK
>
> ​		if state == 0
>
> ​			cwnd += 1
>
> ​		else
>
> ​			cwnd += 1/cwnd
>
> ​		dupACKcount = 0
>
>
>
>  	event : 接收dupACK
>
> ​		dupACKcount++
>
>
>
> ​	event : cwnd >= ssthresh   
>
> ​		state = 1                               #进入拥塞避免状态
>
>
>
> ​	event : timeout or dupACKcount == 3
>
> ​		ssthresh = cwnd / 2
>
> ​		cwnd = 1
>
> ​		state = 0
>
> ​		重传丢失分组（冗余ACK 的下一分组序号）



测试差错检测：

1. 分组丢失（重传）：

2. 丢失ACK：

3. 过早超时：

   接收方处理冗余：

   接收方处理缓存已满：

流控制测试：

1. 是否能够保证 < rwnd
2. 接收到rwnd之后



Python 线程 threading